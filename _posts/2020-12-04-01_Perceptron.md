---
layout: post
title: 感知器
date: 2020-12-04
author: Zhiliang 
tags: [Machine Learning]
toc: true
mathjax: true
---

为了理解神经网络，我们应该先理解神经网络的组成单元——**神经元**。<u>神经元也叫做**感知器**。</u>感知器算法在上个世纪50-70年代很流行，也成功解决了很多问题。并且，感知器算法也是非常简单的。

<!-- more -->

# 深度学习是什么？

在人工智能领域，有一个方法叫机器学习。在机器学习这个方法里，有一类算法叫神经网络。神经网络如下图所示：

![](https://gitee.com/zhiliangj/Typora_Img/raw/master/2256672-c6f640c11a06ac2e.png)

上图中每个圆圈都是一个神经元，每条线表示神经元之间的连接。我们可以看到，上面的神经元被分成了多层，层与层之间的神经元有连接，而层内之间的神经元没有连接。最左边的层叫做**输入层**，这层负责接收输入数据；最右边的层叫**输出层**，我们可以从这层获取神经网络输出数据。输入层和输出层之间的层叫做**隐藏层**。

**隐藏层比较多（大于2）的神经网络叫做深度神经网络。**而深度学习，就是使用深层架构（比如，深度神经网络）的机器学习方法。

那么深层网络和浅层网络相比有什么优势呢？简单来说深层网络能够表达力更强。事实上，一个仅有一个隐藏层的神经网络就能拟合任何一个函数，但是它需要很多很多的神经元。而深层网络用少得多的神经元就能拟合同样的函数。**也就是为了拟合一个函数，要么使用一个浅而宽的网络，要么使用一个深而窄的网络。而后者往往更节约资源。**

深层网络也有劣势，就是它不太容易训练。简单的说，你需要大量的数据，很多的技巧才能训练好一个深层网络。这是个手艺活。

# 感知器

为了理解神经网络，我们应该先理解神经网络的组成单元——**神经元**。<u>神经元也叫做**感知器**。</u>感知器算法在上个世纪50-70年代很流行，也成功解决了很多问题。并且，感知器算法也是非常简单的。

## 感知器的定义

下图是一个感知器：

![](https://gitee.com/zhiliangj/Typora_Img/raw/master/2256672-801d65e79bfc3162.png)

可以看到，一个感知器有如下组成部分：

- **输入权值**：一个感知器可以接收多个输入
$\left(x_1,x_2,\cdots,x_n | x_i\in \Re\right)$，每个输入上有一个权值$w_i\in \Re$，此外还有一个偏置项$b\in \Re$，就是上面的$w_0$。

  > **偏置项又叫偏置单元或者截距顶，他其实就是函数的截距。**与线性方程$y=wx+b$中的b的意义是一致的。

- **激活函数**：感知器的激活函数可以有很多选择，比如我们可以选择下面这个**阶跃函数$f$**来作为激活函数：

$$
f\left( z \right) =\left\{ \begin{array}{l}
1\ z>0\\
0\ otherwise\\
\end{array} \right.
\tag{2.1}
$$

- **输出**：感知器的输出由下面这个公式来计算

$$
y=f\left( \text{w}\cdot \text{x}+b \right)\tag{2.2}
$$

下面用一个简单的例子来帮助理解。

### 用感知器实现`and`函数

我们设计一个感知器，让它来实现`and`运算。我们知道，`and`是一个二元函数（带有两个参数$x_1$和$x_2$），下面是他的真值表：

| $x_1$ | $x_2$ | y    |
| :---- | :---- | :--- |
| 0     | 0     | 0    |
| 0     | 1     | 0    |
| 1     | 0     | 0    |
| 1     | 1     | 1    |

为了 计算方便，我们用0表示**false**，用1表示**true**。我们令$w_1=0.5;w_2=0.5;b=-0.8$，而激活函数$f$就是写前面写出来的阶跃函数，这时，感知器就相当于`and`函数。我们来演算一下：

输入上面真值表中的第一行数据，即$x_1=0;x_2=0$，那么根据公式$2.2$，计算出：

$$
\begin{align}
y&=f\left( \text{w}\cdot \text{x}+b \right)\\
&=f\left( w_1x_1+w_2x_2+b \right)\\
&=f\left( 0.5\times 0+0.5\times 0-0.8 \right)\\
&=f\left( -0.8 \right)\\
&=0\\
\end{align}
$$

也就是当$x_1x_2$都为0的时候，y为0，这就是真值表的第一行。

### 用感知器实现`or`函数

同样，我们也可以用感知器来实现`or`运算。仅仅需要把偏置项$b$的值设置为$-0.3$就可以了。

| $x_1$ | $x_2$ | $y$  |
| :---- | :---- | :--- |
| 0     | 0     | 0    |
| 0     | 1     | 1    |
| 1     | 0     | 1    |
| 1     | 1     | 1    |

此处就不再进行验证。

## 感知器还能做什么

感知器不仅仅能实现简单的布尔运算。它可以拟合任何的线性函数，任何**线性分类**或**线性回归**问题都可以用感知器来解决。前面的布尔运算可以看作是**二分类**问题，即给定一个输入，输出0（属于分类0）或1（属于分类1）。如下面所示，`and`运算是一个线性分类问题，即可以用一条直线把分类0（false，红叉表示）和分类1（true，绿点表示）分开。

![](https://gitee.com/zhiliangj/Typora_Img/raw/master/2256672-acff576747ef4259.png)

然而，感知器却不能实现异或运算，如下图所示，异或运算不是线性的，你无法用一条直线把分类0和分类1分开。

![](https://gitee.com/zhiliangj/Typora_Img/raw/master/2256672-9b651d237936781c.png)

## 感知器的训练

前面的权重项和偏置项的值是如何获得的呢？这就要用到感知器训练算法：将权重项和偏置项初始化为0，然后，利用下面的**感知器规则**迭代的修改$w_i$和$b$，直到训练完成。

$$
\begin{align}
	w_i&\longleftarrow w_i+\varDelta w_i \tag{2.3}\\
	b&\longleftarrow b+\varDelta b \tag{2.4}\\
\end{align}
$$

其中：

$$
\begin{align}
	\varDelta w_i&=\eta \left( t-y \right) x_i \tag{2.5}\\
	\varDelta b&=\eta \left( t-y \right) \tag{2.6}\\
\end{align}
$$

$w_i$是与输入$x_i$对应的权重项，$b$是偏置项。事实上，可以把$b$看作是永远为1的输入$x_b$所对应的权重。$t$是训练样本的**实际值**，一般称之为**label**。而y是感知器的输出值，它是根据**公式(1)**计算得出。$\eta$是一个称为学习速率的常数，其作用是控制每一步调整权的幅度。

每次从训练数据中取出一个样本的输入向量$\text{x}$，使用感知器计算其输出$y$，再根据上面的规则来调整权重。每处理一个样本就调整一次权重。经过多轮迭代后（全部的训练数据被反复处理多轮），就可以训练出感知器的权重，使之实现目标函数。

转载自：[零基础入门深度学习(1) - 感知器](https://www.zybuluo.com/hanbingtao/note/433855)