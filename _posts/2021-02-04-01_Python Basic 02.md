---
layout: post
title: Python基础02
date: 2021-02-04
author: Zhiliang 
tags: [Machine Learning,Python,Basic]
toc: true
mathjax: true
---

Python是一种面向对象的、动态的程序设计语言，具有非常简洁而清晰的语法，既可以用于快速开发程序脚本，也可以用于开发大规模的软件，特别适合于完成各种高层任务。

该博客是阅读Python官方文档，结合自己以前掌握的复制而出😂（因为感觉自己有些还是不太会）。 

 <!-- more -->

# 错误和异常

目前（至少）有两种可区分的错误：*语法错误* 和 *异常*。

## 语法错误

语法错误又称解析错误。解析器会输出出现语法错误的那一行，并显示一个“箭头”，指向这行里面检测到的第一个错误。

## 异常

即使语句或表达式在语法上是正确的，但在尝试执行时，它仍可能会引发错误。 在执行时检测到的错误被称为 *异常*，异常不一定会导致严重后果。

作为异常类型打印的字符串是发生的内置异常的名称。

对于所有内置异常都是如此，但对于用户定义的异常则不一定如此（虽然这是一个有用的规范）。标准的异常类型是内置的标识符（而不是保留关键字）。

**错误信息的前一部分以堆栈回溯的形式显示发生异常时的上下文。**通常它包含列出源代码行的堆栈回溯；但是它不会显示从标准输入中读取的行。

## 处理异常

[`try`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#try) 语句的工作原理如下：

- 首先，执行 *try 子句* （[`try`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#try) 和 [`except`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#except) 关键字之间的（多行）语句）。
- 如果没有异常发生，则跳过 *except 子句* 并完成 [`try`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#try) 语句的执行。
- 如果在执行 try 子句时发生了异常，则跳过该子句中剩下的部分。 然后，如果异常的类型和 [`except`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#except) 关键字后面的异常匹配，则执行 except 子句，然后继续执行 [`try`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#try) 语句之后的代码。
- 如果发生的异常和 except 子句中指定的异常不匹配，则将其传递到外部的 [`try`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#try) 语句中；如果没有找到处理程序，则它是一个 *未处理异常*，执行将停止并显示如上所示的消息。

```python
class B(Exception):
    pass

class C(B):
    pass

class D(C):
    pass

for cls in [B, C, D]:
    try:
        raise cls()
    except D:
        print("D")
    except C:
        print("C")
    except B:
        print("B")
```

最后的 except 子句可以省略异常名，以用作通配符。但请谨慎使用，因为以这种方式很容易掩盖真正的编程错误！

```python
import sys

try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except OSError as err:
    print("OS error: {0}".format(err))
except ValueError:	
    print("Could not convert data to an integer.")
except:
    print("Unexpected error:", sys.exc_info()[0])
    raise
```

[`try`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#try) … [`except`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#except) 语句有一个可选的 *else 子句*，在使用时必须放在所有的 except 子句后面。对于在 try 子句不引发异常时必须执行的代码来说很有用。

> `try`语句成功运行了才会运行`else`

except 子句可以在异常名称后面指定一个变量。这个变量和一个异常实例绑定，它的参数存储在 `instance.args` 中。为了方便起见，异常实例定义了 [`__str__()`](https://docs.python.org/zh-cn/3.6/reference/datamodel.html#object.__str__) ，因此可以直接打印参数而无需引用 `.args` 。也可以在抛出之前首先实例化异常，并根据需要向其添加任何属性。

## 抛出异常

[`raise`](https://docs.python.org/zh-cn/3.6/reference/simple_stmts.html#raise) 语句允许程序员强制发生指定的异常。

[`raise`](https://docs.python.org/zh-cn/3.6/reference/simple_stmts.html#raise) 唯一的参数就是要抛出的异常。这个参数必须是一个异常实例或者是一个异常类（派生自 [`Exception`](https://docs.python.org/zh-cn/3.6/library/exceptions.html#Exception) 的类）。如果传递的是一个异常类，它将通过调用没有参数的构造函数来隐式实例化:

```python
raise ValueError  # shorthand for 'raise ValueError()'
```

## 用户自定义异常

程序可以通过创建新的异常类来命名它们自己的异常。异常通常应该直接或间接地从 [`Exception`](https://docs.python.org/zh-cn/3.6/library/exceptions.html#Exception) 类派生。

大多数异常都定义为名称以“Error”结尾，类似于标准异常的命名。

## 定义清理操作

[`try`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#try) 语句有另一个可选子句，用于定义必须在所有情况下执行的清理操作。

无论是否发生异常，`finally`子句始终在离开`try`语句之前执行。 如果`try`子句中发生了异常且未由`except`子句处理（或在`except`或`else`子句中发生），则在执行`finally`子句后重新引发该异常。 当`try`语句的任何其他子句通过`break`，`continue`或`return`语句留下时，`finally`子句也将在“输出中”执行。

在实际应用程序中，[`finally`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#finally) 子句对于释放外部资源（例如文件或者网络连接）非常有用，无论是否成功使用资源。

## 预定义的清理操作

 [`with`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#with) 语句允许像文件这样的对象能够以一种确保它们得到及时和正确的清理的方式使用。:

```python
with open("myfile.txt") as f:
    for line in f:
        print(line, end="")
```

执行完语句后，即使在处理行时遇到问题，文件 *f* 也始终会被关闭。和文件一样，提供预定义清理操作的对象将在其文档中指出这一点。

# 类

类提供了一种组合数据和功能的方法。 创建一个新类意味着创建一个新的对象 *类型*，从而允许创建一个该类型的新 *实例* 。 每个类的实例可以拥有保存自己状态的属性。 一个类的实例也可以有改变自己状态的（定义在类中的）方法。

类也拥有 Python 天然的动态特性：它们在运行时创建，可以在创建后修改。

## 名称和对象

对象具有个性，多个名称（在多个作用域内）可以绑定到同一个对象。

通常这样做是为了使程序受益，因为别名在某些方面表现得像指针。

## Python 作用域和命名空间

*namespace* （命名空间）是一个从名字到对象的映射。

把任何跟在一个点号之后的名称都称为 *属性* — 例如，在表达式 `z.real` 中，`real` 是对象 `z` 的一个属性。

属性可以是只读或者可写的。如果为后者，那么对属性的赋值是可行的。可写的属性同样可以用 [`del`](https://docs.python.org/zh-cn/3.6/reference/simple_stmts.html#del) 语句删除。

在不同时刻创建的命名空间拥有不同的生存期。

一个 *作用域* 是一个命名空间可直接访问的 Python 程序的文本区域。

作用域被静态确定，但被动态使用。 在程序运行的任何时间，至少有三个命名空间可被直接访问的嵌套作用域：

- 最先搜索的最内部作用域包含局部名称
- 从最近的封闭作用域开始搜索的任何封闭函数的作用域包含非局部名称，也包括非全局名称
- 倒数第二个作用域包含当前模块的全局名称
- 最外面的作用域（最后搜索）是包含内置名称的命名空间

[`global`](https://docs.python.org/zh-cn/3.6/reference/simple_stmts.html#global) 语句可被用来表明特定变量生存于全局作用域并且应当在其中被重新绑定；[`nonlocal`](https://docs.python.org/zh-cn/3.6/reference/simple_stmts.html#nonlocal) 语句表明特定变量生存于外层作用域中并且应当在其中被重新绑定。

### 作用域和命名空间示例

这个例子演示了如何引用不同作用域和名称空间，以及 [`global`](https://docs.python.org/zh-cn/3.6/reference/simple_stmts.html#global) 和 [`nonlocal`](https://docs.python.org/zh-cn/3.6/reference/simple_stmts.html#nonlocal) 会如何影响变量绑定:

```python
def scope_test():
    def do_local():
        spam = "local spam"

    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"

    def do_global():
        global spam
        spam = "global spam"

    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)

scope_test()
print("In global scope:", spam)
```

示例代码的输出是：

```python
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
```

请注意 *局部* 赋值（这是默认状态）不会改变 *scope_test* 对 *spam* 的绑定。 [`nonlocal`](https://docs.python.org/zh-cn/3.6/reference/simple_stmts.html#nonlocal) 赋值会改变 *scope_test* 对 *spam* 的绑定，而 [`global`](https://docs.python.org/zh-cn/3.6/reference/simple_stmts.html#global) 赋值会改变模块层级的绑定。

您还可以在 [`global`](https://docs.python.org/zh-cn/3.6/reference/simple_stmts.html#global) 赋值之前看到之前没有 *spam* 的绑定。

## 初探类

### 类定义语法

最简单的类定义看起来像这样:

```python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
```

类定义与函数定义 ([`def`](https://docs.python.org/zh-cn/3.6/reference/compound_stmts.html#def) 语句) 一样必须被执行才会起作用。

当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域 — 因此，所有对局部变量的赋值都是在这个新命名空间之内。

### 类对象

类对象支持两种操作：属性引用和实例化。

*属性引用* 使用 Python 中所有属性引用所使用的标准语法: `obj.name`。

当一个类定义了 [`__init__()`](https://docs.python.org/zh-cn/3.6/reference/datamodel.html#object.__init__) 方法时，类的实例化操作会自动为新创建的类实例发起调用 [`__init__()`](https://docs.python.org/zh-cn/3.6/reference/datamodel.html#object.__init__)。

> 当然，[`__init__()`](https://docs.python.org/zh-cn/3.6/reference/datamodel.html#object.__init__) 方法还可以有额外参数以实现更高灵活性。 在这种情况下，提供给类实例化运算符的参数将被传递给 [`__init__()`](https://docs.python.org/zh-cn/3.6/reference/datamodel.html#object.__init__)。

### 实例对象

有两种有效的属性名称：数据属性和方法。

### 方法对象

方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。

> 调用 `x.f()` 其实就相当于 `MyClass.f(x)`。 

### 类和实例变量

一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法。

## 补充说明

数据属性会覆盖掉具有相同名称的方法属性；为了避免会在大型程序中导致难以发现的错误的意外名称冲突，明智的做法是使用某种约定来最小化冲突的发生几率。

数据属性可以被方法以及一个对象的普通用户（“客户端”）所引用。

> 实际上，在 Python 中没有任何东西能强制隐藏数据 — 它是完全基于约定的。

方法的第一个参数常常被命名为 `self`。 这也不过就是一个约定: `self` 这一名称在 Python 中绝对没有特殊含义。

方法可以通过使用 `self` 参数的方法属性调用其他方法。

方法可以通过与普通函数相同的方式引用全局名称。

## 继承

如果不支持继承，语言特性就不值得称为“类”。派生类定义的语法如下所示:

```python
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```

派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。

 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。

Python有两个内置函数可被用于继承机制：

- 使用 [`isinstance()`](https://docs.python.org/zh-cn/3.6/library/functions.html#isinstance) 来检查一个实例的类型: `isinstance(obj, int)` 仅会在 `obj.__class__` 为 [`int`](https://docs.python.org/zh-cn/3.6/library/functions.html#int) 或某个派生自 [`int`](https://docs.python.org/zh-cn/3.6/library/functions.html#int) 的类时为 `True`。
- 使用 [`issubclass()`](https://docs.python.org/zh-cn/3.6/library/functions.html#issubclass) 来检查类的继承关系: `issubclass(bool, int)` 为 `True`，因为 [`bool`](https://docs.python.org/zh-cn/3.6/library/functions.html#bool) 是 [`int`](https://docs.python.org/zh-cn/3.6/library/functions.html#int) 的子类。 但是，`issubclass(float, int)` 为 `False`，因为 [`float`](https://docs.python.org/zh-cn/3.6/library/functions.html#float) 不是 [`int`](https://docs.python.org/zh-cn/3.6/library/functions.html#int) 的子类。

### 多重继承

Python 也支持一种多重继承。 带有多个基类的类定义语句如下所示:

```python
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
```

对于多数应用来说，在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从左至右的，当层次结构中存在重叠时不会在同一个类中搜索两次。 因此，如果某一属性在 `DerivedClassName` 中未找到，则会到 `Base1` 中搜索它，然后（递归地）到 `Base1` 的基类中搜索，如果在那里未找到，再到 `Base2` 中搜索，依此类推。

> 方法解析顺序会动态改变以支持对 [`super()`](https://docs.python.org/zh-cn/3.6/library/functions.html#super) 的协同调用
>
> 动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有一个父类可通过多条路径被最底层类所访问）。
>
> 为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化， 保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（即一个类可以被子类化而不影响其父类的优先顺序）。 总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。

## 私有变量

那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (例如 `_spam`) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。

由于存在对于类私有成员的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在对此种机制的有限支持，称为 *名称改写*。 任何形式为 `__spam` 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 `_classname__spam`，其中 `classname` 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。

> 请注意，改写规则的设计主要是为了避免意外冲突；访问或修改被视为私有的变量仍然是可能的。
>
> 请注意传递给 `exec()` 或 `eval()` 的代码不会将发起调用类的类名视作当前类；这类似于 `global` 语句的效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 `getattr()`, `setattr()` 和 `delattr()`，以及对于 `__dict__` 的直接引用。

## 杂项说明

有时会需要使用类似于 Pascal 的“record”或 C 的“struct”这样的数据类型，将一些命名数据项捆绑在一起。 这种情况适合定义一个空类:

```python
class Employee:
    pass

john = Employee()  # Create an empty employee record

# Fill the fields of the record
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
```

## 迭代器

在幕后，for语句在容器对象上调用`iter()`。 该函数返回一个迭代器对象，该对象定义了`__next __()`方法，该方法一次访问一个容器中的元素。 当没有更多元素时，`__next __()`会引发`StopIteration`异常，该异常告知`for`循环终止。 您可以使用`next()`内置函数来调用`__next __()`方法。

```python
>>> s = 'abc'
>>> it = iter(s)
>>> it
<iterator object at 0x00A1DB50>
>>> next(it)
'a'
>>> next(it)
'b'
>>> next(it)
'c'
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    next(it)
StopIteration
```

看过迭代器协议的幕后机制，给你的类添加迭代器行为就很容易了。 定义一个 [`__iter__()`](https://docs.python.org/zh-cn/3.6/reference/datamodel.html#object.__iter__) 方法来返回一个带有 [`__next__()`](https://docs.python.org/zh-cn/3.6/library/stdtypes.html#iterator.__next__) 方法的对象。 如果类已定义了 `__next__()`，则 [`__iter__()`](https://docs.python.org/zh-cn/3.6/reference/datamodel.html#object.__iter__) 可以简单地返回 `self`:

```python
class Reverse:
    """Iterator for looping over a sequence backwards."""
    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
```

```python
>>> rev = Reverse('spam')
>>> iter(rev)
<__main__.Reverse object at 0x00A1DB50>
>>> for char in rev:
...     print(char)
...
m
a
p
s
```

## 生成器

[Generator](https://docs.python.org/zh-cn/3.6/glossary.html#term-generator) 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似标准的函数，但当它们要返回数据时会使用 [`yield`](https://docs.python.org/zh-cn/3.6/reference/simple_stmts.html#yield) 语句。 每次对生成器调用 [`next()`](https://docs.python.org/zh-cn/3.6/library/functions.html#next) 时，它会从上次离开位置恢复执行（它会记住上次执行语句时的所有数据值）。 显示如何非常容易地创建生成器的示例如下:

```python
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]
```

```python
>>> for char in reverse('golf'):
...     print(char)
...
f
l
o
g
```

除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 [`StopIteration`](https://docs.python.org/zh-cn/3.6/library/exceptions.html#StopIteration)。 这些特性结合在一起，使得创建迭代器能与编写常规函数一样容易。

## 生成器表达式

某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方括号。 这种表达式被设计用于生成器将立即被外层函数所使用的情况。 生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。

示例:

```
>>> sum(i*i for i in range(10))                 # sum of squares
285

>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x*y for x,y in zip(xvec, yvec))         # dot product
260

>>> from math import pi, sin
>>> sine_table = {x: sin(x*pi/180) for x in range(0, 91)}

>>> unique_words = set(word  for line in page  for word in line.split())

>>> valedictorian = max((student.gpa, student.name) for student in graduates)

>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))
['f', 'l', 'o', 'g']
```

